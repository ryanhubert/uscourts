#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Ryan HÃ¼bert
# Department of Political Science
# University of California, Davis

"""
dockets.CivilOutcomeClassifier v1.0
A dictionary-based classifier that uses text of docket entries on or near a case
termination date to code the outcome of the case.
"""

import re
import os
from dockets.ClassifierTools import BasicTextFormatter
import nltk

from nltk.stem.snowball import SnowballStemmer
stemmer = SnowballStemmer("english")

# Text Tools
stemmer = SnowballStemmer("english")

stop_words = nltk.corpus.stopwords.words('english')
stop_words = [stemmer.stem(x) for x in stop_words]
stop_words.remove('against')
stop_words.remove('with')

# This sets current path depending on whether in IDE
try:
    current_path =  os.path.dirname(os.path.realpath(__file__))
except:
    current_path = os.getcwd()

# Important search terms
# NB: these words are not used: 'voluntary'
keyphrsS = open(current_path +'/data/phrases_settlement.txt', 'r').read().split('\n')
keyphrsP = open(current_path +'/data/phrases_prejudice.txt', 'r').read().split('\n')
keywords = ['transfer', 'remand', 'vacate', 'reverse', 'affirm', 'default', 'habeas',
            'dismissal', 'dismiss', 'settled', 'settlement', 'joint', 'stipulation', 'stipulated',
            'motion', 'summary', 'judgment','grant', 'denial', 'deny',
            'defendant', 'plaintiff', 'commissioner', 'petitioner', 'respondent',
            'favor', 'against', 'award', 'entitled', 'damages', 'petition',
            'lack', 'jurisdiction', 'standing', 'stay']
keywords = [stemmer.stem(re.sub(' ','_',x)) for x in keywords + keyphrsS + keyphrsP]
keywords = sorted(list(set(keywords)))


settsearch1 = '(' + '|'.join([stemmer.stem(re.sub(' ','_',x)) for x in keyphrsS]) + ')'
settsearch2 = '(case_settl|settlement|settl|joint|consent|stipul)'

outvars = ['forma_pauperis',
            'forum_non_conveniens',
            'r&r',
            'lack_jurisdiction',
            'lack_standing',
            'transfer',
            'default',
            'remand',
            'review',
            'dismiss',
            'settlement',
            'w_prej-voluntary',
            'w_prej-involuntary',
            'wo_prej',
            'wo_prej_d',
            'sumjud',
            'jud',
            'defendant',
            'plaintiff',
            'motions_petitions']

def CivilOutcomeClassifier(entries, habeas=False):
    """
    Take a set of docket entries (for civil cases) and use dictionary methods to
    classify the case outcome(s) using categories in outvars
    :param entries: dict generated by ExtractEntries()
    :param habeas: bool
    :return: tuple of dict with classifications and cleaned text
    """

    outcome = {x: False for x in outvars}
    if entries == {}:
        return (outcome, '')

    # Break entries into clauses (useful down below)
    clauses = []
    for string in [entries[x]['entry_text'] for x in entries]:
        # We use "settle" to classify cases as settlement, and this judge's
        # name is causing problems
        string = string.replace('Benjamin H. Settle'.lower(), ' ')
        string = string.replace('Benjamin Settle'.lower(), ' ')
        clauses.extend([y for x in BasicTextFormatter(string) for y in x if y != ""])

    ## Catch some useful stuff
    if 'forma pauperis' in ' '.join(clauses):
        outcome['forma_pauperis'] = True
    if 'forum non conveniens' in ' '.join(clauses):
        outcome['forum_non_conveniens'] = True

    # clauses = [re.sub('  +',' ',x) for x in clauses]
    clauses = [[x for x in y.split(' ') if re.search("[a-z]", x) and len(x) > 1] for y in clauses]
    clauses = [[stemmer.stem(x) for x in y] for y in clauses]
    clauses = [[x for x in y if x in keywords or '_' in x] for y in clauses]
    clauses = [x for x in clauses if x != []]

    text_merge = '-'.join(['.'.join(x) for x in clauses])

    # CODE OUTCOMES ACCORDING TO RULES

    ## Find R&Rs
    if 'r_r' in text_merge and 'adopt' in text_merge:
        outcome['r&r'] = True

    ## Case transfered elsewhere, not terminated
    if 'transfer' in text_merge:
        outcome['transfer'] = True

    ## Default judgment, favors plaintiff
    if 'default.judgment' in text_merge and 'dismiss' not in text_merge:
        outcome['default'] = True

        ## Review of agencies and state courts: affirm, reverse, remand
    if 'remand' in text_merge:
        outcome['remand'] = True
        if re.search(settsearch2, text_merge):
            outcome['settlement'] = True

    if 'affirm' in text_merge:
        outcome['review'] = True
        outcome['defendant'] = True  # Affirm = pro-defendant (eg, SSA)

    if 'revers' in text_merge:
        outcome['review'] = True
        outcome['plaintiff'] = True

    ## Habeas Cases
    if habeas == True or 'habea' in text_merge:
        if 'petit.deni' in text_merge and not 'petit.grant' in text_merge:
            outcome['dismiss'] = True
            if not 'without_prejudic' in text_merge:
                outcome['w_prej-involuntary'] = True
            else:
                outcome['wo_prej'] = True
        if 'petit.grant' in text_merge and not 'petit.deni' in text_merge:
            outcome['plaintiff'] = True
        if ('deni' in text_merge or 'dismiss' in text_merge) and not 'grant' in text_merge:
            outcome['dismiss'] = True
            if not 'without_prejudic' in text_merge:
                outcome['w_prej-involuntary'] = True
            else:
                outcome['wo_prej'] = True
        if ('deni' not in text_merge and 'dismiss' not in text_merge) and 'grant' in text_merge:
            outcome['plaintiff'] = True

    ## Settlements and dismissals
    if re.search(settsearch1, text_merge):
        outcome['dismiss'] = True
        outcome['settlement'] = True
        outcome['w_prej-voluntary'] = True
    elif 'dismiss' in text_merge and (habeas == False and 'habea' not in text_merge):
        outcome['dismiss'] = True
        # Prejudice language in text (all allowed, e.g, dismissals of multiple claims)
        if 'without_prejudic' in text_merge:
            outcome['wo_prej'] = True
        if 'with_prejudic' in text_merge:
            if re.search(settsearch2, text_merge):
                outcome['settlement'] = True
                outcome['w_prej-voluntary'] = True
            else:
                outcome['w_prej-involuntary'] = True
        # No prejudice language at all
        if 'without_prejudic' not in text_merge and 'with_prejudic' not in text_merge:
            if 'stipul' in text_merge and 'proposed_ord' in text_merge:
                outcome['settlement'] = True
                outcome['w_prej-voluntary'] = True
            else:  # This is our reversion classification -- when not clear what kind of dism
                outcome['wo_prej_d'] = True

    ## Wrong venue?
    if 'lack.jurisdict' in text_merge:
        outcome['lack_jurisdiction'] = True
    if 'lack.stand' in text_merge:
        outcome['lack_standing'] = True

    ## Identify summary judgments, other judgments (e.g., after trial)

    ## Also keep all formatted strings related to motions and petitions
    ## can use later to code outcomes that are blank
    mss = []
    for clause in clauses:
        i = '.'.join(clause)
        if 'petit' in i or 'motion' in i:
            i = i.replace('petit','motion')
            if 'by_def' in i or 'defend.motion' in i:
                mss.append('defendant/mot_pet')
                for r in re.findall('(?:grant|deni)', i):
                    mss.append('defendant/mot_pet/' + r)
            if ('by_pla' in i or 'plaintiff.motion' in i) and 'grant' in i:
                mss.append('plaintiff/mot_pet')
                for r in re.findall('(?:grant|deni)', i):
                    mss.append('plaintiff/mot_pet/' + r)
        if 'summari.judgment' in i and not 'deni' in i:
            outcome['sumjud'] = True
            if 'motion.summari.judgment' in i and ('grant' in i and 'deni' not in i):
                if 'by_def' in i or 'defend' in i:
                    outcome['defendant'] = True
                if 'by_pla' in i or 'plaintiff' in i:
                    outcome['plaintiff'] = True
        elif 'judgment' in i and not 'default.judgment' in i:
            if not any(outcome[z] for z in outcome if
                       z not in ['r&r', 'lack_jurisdiction', 'lack_standing', 'forma_pauperis',
                                 'forum_non_conveniens']):
                outcome['jud'] = True
        else:  # do not code direction if language above not found
            continue

    mss = ["" if any((x in z and len(x) < len(z)) for z in mss) else x for x in mss]
    mss = [x for x in mss if x != ""]

    ## Code directions if a judgment is identified
    ## This is overly inclusive -- will code D and P decisions liberally!
    if outcome['jud'] == True or outcome['sumjud'] == True:
        if 'favor.defend' in text_merge or 'against.plaintiff' in text_merge:
            outcome['defendant'] = True
        if 'favor.plaintiff' in text_merge or 'against.defend' in text_merge:
            outcome['plaintiff'] = True
        if 'award.platiff.damag' in text_merge:
            outcome['plaintiff'] = True
        if 'plaintiff.entitl.judgment' in text_merge:
            outcome['plaintiff'] = True
        if 'defend.entitl.judgment' in text_merge:
            outcome['defendant'] = True

    outcome['motions_petitions'] = sorted(mss)

    return outcome, text_merge